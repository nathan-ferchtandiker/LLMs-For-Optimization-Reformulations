{
  "data_generation_code": "import random\nimport numpy as np\nfrom typing import Dict, List, Any\n\n\ndef _make_sym_list(prefix: str, n: int) -> List[str]:\n    \"\"\"Helper that returns ['prefix1', 'prefix2', ...]\"\"\"\n    return [f\"{prefix}{i+1}\" for i in range(n)]\n\n\ndef generate_data(seed: int | None = 42) -> Dict[str, Any]:\n    \"\"\"Create a deterministic but random-looking data set for the tower optimisation model.\n\n    Parameters\n    ----------\n    seed : int | None, default 42\n        A seed for both the `random` and `numpy.random` RNGs.  Using the same seed\n        always returns exactly the same dictionary.\n\n    Returns\n    -------\n    Dict[str, Any]\n        A fully-populated data dictionary; every key is a **string** and every\n        nested key is a **string** as well (as required).\n    \"\"\"\n    # ------------------------------------------------------------------\n    #                        RNG initialisation\n    # ------------------------------------------------------------------\n    if seed is not None:\n        random.seed(seed)\n        np.random.seed(seed)\n\n    # ------------------------------------------------------------------\n    #                               SETS\n    # ------------------------------------------------------------------\n    sectors: List[str] = [\"social\", \"middle\", \"free\"]  # I\n    areas_numeric: List[int] = [50, 75, 100, 125]        # J (stored as numbers first)\n    areas: List[int] = areas_numeric                     # keep ints inside list, keys later are str\n    owners: List[str] = [\"corporation\", \"investor\", \"private\"]  # H\n\n    n_configs = 4\n    floor_configurations: List[str] = _make_sym_list(\"C\", n_configs)  # V\n\n    apartments_in_config: Dict[str, List[str]] = {}\n    apartment_area: Dict[str, Dict[str, int]] = {}\n    apartments_per_config: Dict[str, int] = {}\n    apartments_by_area_config: Dict[str, Dict[str, int]] = {str(a): {v: 0 for v in floor_configurations} for a in areas_numeric}\n\n    # Each configuration gets 6 apartments; the area distribution is purposely\n    # symmetric: every configuration has **exactly** 1 apartment of each area\n    # 50, 75, 100 and 2 apartments of area 125.\n    for v in floor_configurations:\n        a_names = _make_sym_list(\"A\", 6)\n        apartments_in_config[v] = a_names\n        apartments_per_config[v] = len(a_names)\n\n        # one apartment of 50, 75, 100 sqm; two of 125 sqm; one random repeat\n        areas_this_conf = [50, 75, 100, 125, 125, random.choice([50, 75, 100])]\n        random.shuffle(areas_this_conf)\n\n        apartment_area[v] = {}\n        for a_name, a_size in zip(a_names, areas_this_conf, strict=True):\n            apartment_area[v][a_name] = a_size\n            apartments_by_area_config[str(a_size)][v] += 1\n\n    # Floors: 8 storeys, stored as strings to comply with 100 % string-key rule\n    total_floors: int = 8\n    floors: List[str] = [str(k + 1) for k in range(total_floors)]  # K\n\n    # ------------------------------------------------------------------\n    #                            PARAMETERS\n    # ------------------------------------------------------------------\n    # Profit per apartment:  p_{i j h}\n    profit_per_apartment: Dict[str, Dict[str, Dict[str, int]]] = {}\n    for i in sectors:\n        profit_per_apartment[i] = {}\n        for j in areas_numeric:\n            profit_per_apartment[i][str(j)] = {}\n            # Base profit grows linearly with the area, scaled by a sector-specific\n            # multiplier.  A 0\u20132 percent random noise is added but the same profit\n            # can appear multiple times (symmetry).\n            multiplier = {\"social\": 8, \"middle\": 10, \"free\": 12}[i]\n            base_val = multiplier * j  # e.g. 8 \u00d7 50 = 400\n            for h in owners:\n                noise = np.random.randint(-2, 3)  # \u00b12\n                profit_per_apartment[i][str(j)][h] = base_val + noise\n\n    # Minimum area requirement m_{ih}\n    min_area_requirement: Dict[str, Dict[str, int]] = {}\n    for i in sectors:\n        min_area_requirement[i] = {}\n        for h in owners:\n            # All minima are symmetric across owners but slightly differ between\n            # sectors; they are always \u2264 the minimum area 50 to keep feasibility.\n            min_val = {\"social\": 48, \"middle\": 60, \"free\": 0}[i]\n            min_area_requirement[i][h] = min_val\n\n    # Minimum percentage of apartments per sector b_i\n    min_sector_percentage: Dict[str, float] = {\"social\": 0.20, \"middle\": 0.30, \"free\": 0.0}\n\n    # Minimum average area per sector s_i (in m\u00b2)\n    min_avg_area_per_sector: Dict[str, int] = {\"social\": 60, \"middle\": 75, \"free\": 0}\n\n    # Minimum ownership share per owner o_h\n    min_ownership_percentage: Dict[str, float] = {\"corporation\": 0.25, \"investor\": 0.25, \"private\": 0.20}\n\n    # ------------------------------------------------------------------\n    #                     COLLECT EVERYTHING IN ONE DICT\n    # ------------------------------------------------------------------\n    data: Dict[str, Any] = {\n        # --- Sets ------------------------------------------------------\n        \"sectors\": sectors,\n        \"areas\": areas,  # integers are allowed in the list itself\n        \"owners\": owners,\n        \"floor_configurations\": floor_configurations,\n        \"apartments_in_config\": apartments_in_config,\n        \"floors\": floors,\n        # --- Parameters -----------------------------------------------\n        \"profit_per_apartment\": profit_per_apartment,\n        \"min_area_requirement\": min_area_requirement,\n        \"min_sector_percentage\": min_sector_percentage,\n        \"min_avg_area_per_sector\": min_avg_area_per_sector,\n        \"min_ownership_percentage\": min_ownership_percentage,\n        \"apartment_area\": apartment_area,\n        \"apartments_per_config\": apartments_per_config,\n        \"apartments_by_area_config\": apartments_by_area_config,\n        \"total_floors\": total_floors,\n    }\n\n    return data\n",
  "description": "Generator for a compact yet non-trivial test instance of the residential-tower design problem.  The script builds four floor configurations, each with six apartments whose areas are chosen so that every configuration has the same distribution (symmetry).  Profit values are deterministically randomised within \u00b12 of a base that scales with the apartment size and sector.  All keys in all nested dictionaries are strings, ensuring JSON serialisability and compliance with the specification."
}